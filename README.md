# WB-Tech_L1

# Устные вопросы по Go

## 1. Какой самый эффективный способ конкатенации строк?

**Ответ:** Самым эффективным способом конкатенации строк в Go является использование `strings.Builder`, так как он минимизирует количество выделений памяти и копирований.

## 2. Что такое интерфейсы, как они применяются в Go?

**Ответ:** Интерфейсы в Go определяют набор методов, которые тип должен реализовать. Они обеспечивают абстракцию и полиморфизм, позволяя функциям работать с различными типами, реализующими один интерфейс.

## 3. Чем отличаются RWMutex от Mutex?

**Ответ:** `RWMutex` позволяет нескольким читателям одновременно доступ к ресурсам, но только одному писателю, тогда как `Mutex` блокирует доступ для всех, кроме одного явного владельца.

## 4. Чем отличаются буферизированные и не буферизированные каналы?

**Ответ:** Не буферизированные каналы требуют синхронной передачи между отправителем и получателем, тогда как буферизированные каналы позволяют отправлять определённое количество данных без немедленного приема.

## 5. Какой размер у структуры `struct{}{}`?

**Ответ:** Структура `struct{}{}` имеет размер 0 байт, так как она не содержит полей.

## 6. Есть ли в Go перегрузка методов или операторов?

**Ответ:** Нет, в Go нет перегрузки методов или операторов. Каждый метод и оператор имеет уникальное имя и сигнатуру.

## 7. В какой последовательности будут выведены элементы `map[int]int`?

**Ответ:** Порядок вывода элементов из карты (`map`) в Go не гарантируется и является произвольным.

## 8. В чем разница `make` и `new`?

**Ответ:** `new` выделяет память для типа и возвращает указатель на него, тогда как `make` используется для инициализации встроенных типов, таких как срезы, карты и каналы.

## 9. Сколько существует способов задать переменную типа slice или map?

**Ответ:** Существует несколько способов создания переменных типов `slice` и `map`, включая использование литералов, функции `make`, оператора `new` и объявление без инициализации.

## 10. Что выведет данная программа и почему?

```go
package main

import (
	"fmt"
)

func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```

**Ответ:**
```
1
1
```

Функция `update` изменяет локальную копию указателя `p`, не влияя на оригинальный указатель в `main`.

## 11. Что выведет данная программа и почему?

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```

**Ответ:** Программа зависнет и не выведет "exit", так как `WaitGroup` передается по значению, и основной поток бесконечно ждёт завершения горутин.

## 12. Что выведет данная программа и почему?

```go
package main

import (
	"fmt"
)

func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
```

**Ответ:** Программа выведет `0`, так как внутри блока `if` объявляется новая переменная `n`, которая не влияет на внешнее `n`.

## 13. Что выведет данная программа и почему?

```go
package main

import (
	"fmt"
)

func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```

**Ответ:** Программа выведет `[100 2 3 4 5]`, поскольку изменение `v[0]` отражается на `a`, а `append` внутри функции не влияет на исходный срез.

## 14. Что выведет данная программа и почему?

```go
package main

import (
	"fmt"
)

func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```

**Ответ:** Программа выведет `[b b a][a a]`, так как `append` создаёт новый срез внутри функции, и изменения внутри функции не затрагивают оригинальный срез в `main`.