package main

import (
	"fmt"
	"sort"
)

// IntersectionTwoPointers возвращает пересечение двух неупорядоченных множеств (set1 и set2)
// путем сортировки обоих массивов и использования двух указателей для эффективного поиска общих элементов.
// Параметры:
// - set1: первый срез целых чисел.
// - set2: второй срез целых чисел.
// Возвращает:
// - срез целых чисел, представляющий пересечение set1 и set2 без дубликатов.
func IntersectionTwoPointers(set1, set2 []int) []int {
	// Сортируем оба множества для упорядочивания элементов.
	sort.Ints(set1)
	sort.Ints(set2)

	// Инициализируем срез для хранения пересечения.
	intersection := []int{}
	// Инициализируем два указателя для перебора сортированных массивов.
	i, j := 0, 0

	// Перебираем оба массива пока оба указателя не достигнут конца соответствующих массивов.
	for i < len(set1) && j < len(set2) {
		if set1[i] == set2[j] {
			// Избегаем добавления дубликатов в результат.
			if len(intersection) == 0 || intersection[len(intersection)-1] != set1[i] {
				intersection = append(intersection, set1[i]) // Добавляем общий элемент.
			}
			i++ // Сдвигаем оба указателя, так как текущие элементы совпали.
			j++
		} else if set1[i] < set2[j] {
			i++ // Сдвигаем указатель первого массива, так как текущий элемент меньше.
		} else {
			j++ // Сдвигаем указатель второго массива, так как текущий элемент меньше.
		}
	}

	return intersection // Возвращаем найденное пересечение.
}

func main() {
	// Определяем два набора чисел в произвольном порядке.
	set1 := []int{5, 3, 1, 4, 2}
	set2 := []int{8, 6, 5, 4, 7}

	// Вызываем функцию IntersectionTwoPointers для получения пересечения set1 и set2.
	result := IntersectionTwoPointers(set1, set2)

	// Выводим результат на стандартный вывод.
	fmt.Println("Пересечение (два указателя):", result)
}
