package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/signal"
	"sync"
	"time"
)

// Worker представляет структуру каждого воркера.
type Worker struct {
	ID int // Идентификатор воркера
}

// work выполняет обработку задач из канала.
// При завершении работы воркер уведомляет WaitGroup.
func (w *Worker) work(ctx context.Context, jobs <-chan string, wg *sync.WaitGroup) {
	defer wg.Done() // Уменьшаем счетчик WaitGroup при завершении воркера

	for {
		select {
		case <-ctx.Done():
			// Получен сигнал отмены, завершаем работу воркера
			fmt.Printf("Воркер %d завершает работу.\n", w.ID)
			return
		case job, ok := <-jobs:
			if !ok {
				// Канал закрыт, завершаем работу воркера
				fmt.Printf("Воркер %d обнаружил закрытый канал и завершает работу.\n", w.ID)
				return
			}
			// Обработка полученных данных
			fmt.Printf("Воркер %d обработал: %s\n", w.ID, job)
			// Симулируем время обработки
			time.Sleep(time.Millisecond * 500)
		}
	}
}

func main() {
	// Парсим флаг для количества воркеров
	numWorkers := flag.Int("workers", 5, "Количество воркеров")
	flag.Parse()

	// Создаем канал для передачи данных
	jobs := make(chan string)

	// Создаем WaitGroup для ожидания завершения всех воркеров
	var wg sync.WaitGroup

	// Создаем контекст с возможностью отмены
	ctx, cancel := context.WithCancel(context.Background())

	// Обрабатываем сигналы ОС для graceful shutdown
	sigint := make(chan os.Signal, 1)
	signal.Notify(sigint, os.Interrupt) // Слушаем сигнал прерывания (Ctrl+C)

	// Запускаем N воркеров
	for i := 1; i <= *numWorkers; i++ {
		worker := Worker{ID: i}
		wg.Add(1)
		go worker.work(ctx, jobs, &wg)
	}

	// Горутина для постоянной записи данных в канал
	go func() {
		count := 1
		for {
			job := fmt.Sprintf("Задача %d", count)
			select {
			case <-ctx.Done():
				// Получен сигнал отмены, прекращаем отправку данных
				fmt.Println("Прекращаем отправку данных в канал.")
				close(jobs) // Закрываем канал, чтобы воркеры могли завершиться
				return
			case jobs <- job:
				// Отправляем данные в канал
				fmt.Printf("Отправлено: %s\n", job)
				count++
				time.Sleep(time.Millisecond * 300) // Интервал между отправками
			}
		}
	}()

	/*
		Почему здесь используется 2 case, а не case и default?
		Если использовать default, то попытка отправить данные в канал будет неблокирующей.
		Это может привести к тому, что данные не будут отправлены, если канал не готов принимать их,
		что либо приведет к потере данных, либо к бесконечным попыткам отправки,
		нагружая процессор.

		Вместо этого, использование двух блокирующих cases позволяет:
		1. Дожидаться, пока канал будет готов принять данные, и отправить их.
		2. Немедленно реагировать на сигнал отмены из контекста,
		   позволяя горутине корректно завершить работу.

		Таким образом, мы обеспечиваем надежную отправку данных и возможность быстрого завершения работы при необходимости.
	*/

	// Блокируем основной поток до получения сигнала прерывания
	<-sigint
	fmt.Println("\nПолучен сигнал прерывания. Завершаем работу...")

	// Вызываем отмену контекста, уведомляя воркеров об остановке
	cancel()

	// Ожидаем завершения всех воркеров
	wg.Wait()

	fmt.Println("Все воркеры завершили работу. Программа завершена.")
}
